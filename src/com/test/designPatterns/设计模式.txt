设计模式原则：
  1.单一职责原则：一个类应该尽可能的有少的职责
  2.开闭原则 ：对扩展打开，对修改关闭
  3.里氏代换原则 ：能用子类的地方，都可以用它的父类
  4.接口隔离原则 ：尽量用单一职责的接口，而不用复合接口
  5.依赖倒转原则 ：要针对接口编程，而不是具体实现类
  6.迪米特原则 ：类与类之间尽可能少的关联，降低耦合
  7.复用组合原则 ：类与类之间的关联尽可能使用组合复用，而不是继承

创建型模式：
  1.工厂模式:  定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。
  		            工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)
  		            或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。
  		         
  2.抽象工厂模式: 提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。
  
  3.单例模式:  确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。
  
  4.建造者模式: 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。
  
  5.原型模式 :  使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。
结构性模式：
  1.适配器模式 : 将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。
  			适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。
  			
  2.装饰模式  ：     动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。
  
  3.享元模式 :  运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。
  			由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式
  			
  4.外观模式  :  为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
  
  5.代理模式  :  给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。
  
  6.组合模式 :  组合多个对象形成树形结构以表示具有“整体―部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，
  			组合模式又可以称为“整体―部分”(Part-Whole)模式，它是一种对象结构型模式。
  
  7.桥接模式 :  将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，
			又称为柄体(Handle and Body)模式或接口(Interface)模式。
行为性模式：
  1.责任链模式: 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。
  
  2.命令模式   : 将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，
  			其别名为动作(Action)模式或事务(Transaction)模式。
  
  3.解释器模式  : 定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。解释器模式是一种类行为型模式。
  
  4.迭代器模式  : 提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式。
  
  5.观察者模式  : 定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、
  			模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。
  			
  6.访问者模式  : 提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式是一种对象行为型模式。
  
  7.备忘录模式  : 在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。它是一种对象行为型模式，其别名为Token。
  
  8.策略模式 : 定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。策略模式是一种对象行为型模式。
  
  9.状态模式 : 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。
  
  10.模板方法模式 : 定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
  
  11.中介者模式  : 用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，
  			     它是一种对象行为型模式。
  			     
     学习心得：
    1.装饰模式，代理模式，中介者模式之间的区别
      	装饰模式是动态的给一个对象增加新的功能，在装饰类中通过构造函数把原有对象作为参数传入，主要目的是添加功能而不控制原有的方法。
      	另外装饰模式还可以对装饰进行层层装饰。
      	代理模式是通过一个代理类来控制对原有对象的访问，在代理类中新生成一个原有对象的实例，和装饰模式一样都属于结构性模式。
      	中介者模式是为了完成多个不相关的类的交互，减少类与类之间的关联，属于行为型模式。
    2.工厂模式与建造者模式的区别
    	工厂模式是将对象的实例化延续到子类，只需要调用不同的工厂方法就可以实例化不同的子类对象。
    	抽象工厂方法是提供一个创建一系列相关或相互以来对象的接口，而无需指定它们的具体的类，这就是抽象工厂模式的用意
    	建造者模式是将生成一个产品的内部表象和生成的过程分开，从而一个建造过程可以生成不同的表象。
    3.	
  